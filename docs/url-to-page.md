# 从输入 URL 到页面展示的全过程

这是一个经典的前端面试题，也是理解浏览器工作原理的核心。

## 一、 输入 URL 并回车（用户操作）

用户在浏览器地址栏输入 URL（如 `https://www.example.com`）并按下回车，浏览器首先会**校验 URL 格式**：

1.  **判断**: 是合法网址还是搜索关键词（若为关键词则跳转搜索引擎）。
2.  **缓存检查**: 若为合法 URL，会先从本地缓存（如浏览器历史记录、系统 DNS 缓存）中查找是否有该域名的记录，优先使用缓存提升速度。

## 二、 DNS 域名解析（域名 → IP 地址）

URL 中的域名（如 `www.example.com`）无法直接被网络识别，需要通过 **DNS（域名系统）** 解析成服务器的 **IP 地址**。

1.  **本地缓存查询**: 浏览器缓存 → 系统缓存 → 路由器缓存。若有记录直接返回 IP，跳过后续步骤。
2.  **递归查询（本地 DNS 服务器）**: 若无本地缓存，浏览器向 **本地 DNS 服务器**（ISP 运营商提供或手动配置）发起请求。
3.  **迭代查询**:
    *   本地 DNS 问 **根域名服务器** (Root Server)。
    *   根服务器指引去 **顶级域名服务器** (TLD Server, 如 `.com` 服务器)。
    *   顶级服务器指引去 **权威域名服务器** (Authority Server, 该域名的专属服务器)。
    *   权威服务器返回目标服务器的 **IP 地址** 给本地 DNS，再由本地 DNS 返回给浏览器。

> **补充**: 如果是 HTTPS 网址，后续还会验证 SSL 证书，确保连接安全。

## 三、 建立 TCP 连接（三次握手）

浏览器拿到服务器 IP 后，需要和服务器建立 **TCP 可靠连接**（三次握手）：

1.  **SYN**: 客户端（浏览器）发送 `SYN` 报文，请求建立连接。
2.  **SYN+ACK**: 服务端返回 `SYN+ACK` 报文，确认收到请求并同意建立。
3.  **ACK**: 客户端发送 `ACK` 报文，确认连接，TCP 连接正式建立 (`ESTABLISHED` 状态)。

> **补充**:
> *   HTTP/1.1 默认是 **长连接** (Keep-Alive)，一次 TCP 连接可传输多个 HTTP 请求。
> *   HTTP/2 支持 **多路复用** (Multiplexing)，一个 TCP 连接可并发处理多个请求，效率更高。

## 四、 发送 HTTP/HTTPS 请求

TCP 连接建立后，浏览器向服务器发送 **HTTP 请求报文**：

*   **请求方法**: `GET`（获取页面）、`POST` 等。
*   **请求头**: `User-Agent`、`Cookie`、`Accept` 等。
*   **请求体**: `GET` 无请求体，`POST` 携带参数。

根据服务器的**渲染模式**，返回内容会有所不同：

| 渲染模式 | 服务端返回内容 |
| :--- | :--- |
| **SPA** | **空 HTML 骨架**（如 `<div id="app"></div>`） + 大体积客户端 JS 包 |
| **SSR** | **包含完整内容的 HTML**（服务端已渲染） + 客户端 JS 包（用于后续水合） |
| **SSG** | **静态 HTML 文件**（构建时生成的，直接从 CDN 返回） |

## 五、 服务端处理请求并返回响应

服务器接收请求后，根据架构处理：

1.  **静态资源**: 直接读取文件返回（HTML/CSS/JS/图片）。
2.  **SSR 场景**: 执行服务端代码 → 预取数据 → 渲染组件生成 HTML → 返回。
3.  **SPA 场景**: 直接返回预设的空 HTML 骨架。
4.  **API 接口**: 业务逻辑处理 → 查数据库 → 返回 JSON。

**HTTP 响应报文** 包含：
*   **状态码**: `200` (成功)、`404` (未找到)、`500` (错误)。
*   **响应头**: `Content-Type`、`Cache-Control` (缓存策略)。
*   **响应体**: HTML 内容、JSON 数据等。

## 六、 浏览器接收响应并解析渲染页面

这是前端最核心的环节，浏览器分步骤渲染页面：

1.  **解析 HTML → 构建 DOM 树**: 逐行解析 HTML 标签，生成 DOM 树。
2.  **解析 CSS → 构建 CSSOM 树**: 解析 `<link>` 或 `<style>`，生成 CSSOM 树。
3.  **合成渲染树 (Render Tree)**: 结合 DOM 和 CSSOM，生成只包含显示节点的渲染树（排除 `display: none`）。
4.  **布局 (Layout/回流)**: 计算每个节点的位置、大小。
    > **注意**: 布局阶段若修改 DOM/CSS 尺寸，会触发 **回流 (Reflow)**，性能开销大。
5.  **绘制 (Paint/重绘)**: 将节点绘制到屏幕上（填充颜色、文字等）。
    > **注意**: 仅修改颜色等不影响布局的属性，触发 **重绘 (Repaint)**，开销小于回流。
6.  **客户端 JS 执行与水合 (关键差异点)**:
    *   **SPA**: 加载 JS → 执行 JS → AJAX 请求数据 → 动态生成 DOM → 更新页面（此时才看到内容）。
    *   **SSR**: 先展示 HTML（首屏无白屏）→ 加载并执行 JS → 完成 **水合 (Hydration)** → 变为可交互应用。

## 七、 页面加载完成与后续操作

*   触发 `DOMContentLoaded` (DOM 解析完成) 和 `load` (所有资源加载完成) 事件。
*   **SPA 后续**: 页面跳转不重复上述全流程，而是通过 **前端路由** 动态切换组件，仅请求数据，无刷新。

## 总结

流程简化：
**输入 URL → DNS 解析 → TCP 三次握手 → 发送 HTTP 请求 → 服务端处理并响应 → 浏览器解析渲染 → 页面展示**

其中，**服务端的渲染模式（SPA/SSR/SSG）** 会直接影响“服务端响应内容”和“浏览器渲染效率”，这也是前端架构选型的核心考量点。
